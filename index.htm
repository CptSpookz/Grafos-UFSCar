<html>
    <head>
        <meta charset="utf-8">
        <title>Trabalho Final Grafos - UFSCar 2017/1</title>

        <!-- Bootstrap Core CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">

        <!-- Template Custom Fonts -->
        <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Clean Blog CSS -->
        <link href="pages/css/clean-blog.css" rel="stylesheet" type="text/css">

        <!-- Highlight JS -->
        <link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    </head>

    <body>
        <!-- Page Header -->
        <header class="masthead" style="background-image: url('img/home-bg.jpg')">
            <div class="overlay"></div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-md-10 mx-auto">
                        <div class="site-heading">
                            <h1>Grafos</h1>
                            <span class="subheading">Universidade Federal de São Carlos</span>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Page Content -->        
        <article>
            <div class="container">
                <div class="row">
                    <div class="col-lg-10 col-md-10 mx-auto">
                        <!-- Introduction -->
                        <p>Esse site é um agregado de pequenos tutoriais para a disciplina de Teoria dos Grafos, do segundo semestre do ano de 2017, ministrada pelo Prof. Dr. Alexandre Levada. Os alunos integrantes desse grupo são:</p>

                        <!-- Markov Chain -->
                        <h1 class="section-heading">Cadeia de Markov</h1>

                        <hr>

                        <!-- Prim -->
                        <h1 class="section-heading">Algoritmo de Prim</h1>
                        <p>O algoritmo de Prim é um dos mais utilizados para encontrar árvores mínimas geradoras, ou MSTs, dado um determinado grafo. Nesse tutorial, iremos criar passo à passo uma função que nos retorna uma MST, utilizando Prim.</p>
			<p>Inicialmente, criamos uma função chamada prim, que recebe um objeto do tipo <code>networkx.Graph</code>. Esse é o grafo que será utilizado para encontrar a árvore mínima geradora. Também iremos adicionar um novo objeto na função, chamado de <code>mst</code>, que será retornado no final da execução. Essa será a árvore resultante.</p>
			<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co"># Função que implementa o algoritmo de Prim. Recebe um nx.Graph e retorna um nx.DiGraph</span></a>
			<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">def</span> prim(graph):</a>
			<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
			<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="co"># Digrafo resultante</span></a>
			<a class="sourceLine" id="cb1-5" data-line-number="5">    mst <span class="op">=</span> nx.DiGraph()</a>
			<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
			<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="cf">return</span> mst</a></code></pre></div>
			<p>O passo seguinte é adicionar as propriedades de <em>cor (branco se não visitado, preto se foi), lambda (distância mínima encontrada) e pi (pai do vértice)</em>. Para isso, podemos utilizar os atributos das vértices do próprio grafo recebido pela função. Inicializamos então todos os vértices com a cor branca, todos eles sem pai e todos menos o vértice inicial com a lambda infinito. O lambda do vértice inicial deve receber 0, para que o algoritmo tenha um vértice para começar.</p>
			<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># Inicializa as cores dos vértices como branco</span></a>
			<a class="sourceLine" id="cb2-2" data-line-number="2">nx.set_node_attributes(graph, <span class="st">&#39;white&#39;</span>, <span class="st">&#39;color&#39;</span>)</a>
			<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
			<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="co"># Inicializa o pi(pai) dos vértices como None</span></a>
			<a class="sourceLine" id="cb2-5" data-line-number="5">nx.set_node_attributes(graph, <span class="va">None</span>, <span class="st">&#39;pi&#39;</span>)</a>
			<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
			<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="co"># Inicializa o lambda(distância mínima) dos vértices como infinito</span></a>
			<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="co"># O vértice inicial recebe 0</span></a>
			<a class="sourceLine" id="cb2-9" data-line-number="9">nx.set_node_attributes(graph, <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>), <span class="st">&#39;lambda&#39;</span>)</a>
			<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="cf">for</span> node <span class="kw">in</span> graph.nodes:</a>
			<a class="sourceLine" id="cb2-11" data-line-number="11">    nx.set_node_attributes(graph, {node: <span class="dv">0</span>}, <span class="st">&#39;lambda&#39;</span>)</a>
			<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="cf">break</span>   <span class="co"># Executa o loop para apenas um nó</span></a></code></pre></div>
			<p>Em seguida, iremos criar o loop principal, que será executado enquanto existirem vértices com a cor branca (não visitados). Ele deverá selecionar o vértice com menor lambda. Para isso, fazemos o seguinte:</p>
			<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co"># Enquanto existir um vértice não visitado, continua visitando</span></a>
			<a class="sourceLine" id="cb3-2" data-line-number="2">nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>) <span class="co"># nos dá todos os vértices do grafo, junto com seus atributos</span></a>
			<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="cf">while</span> <span class="bu">any</span>(node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span> <span class="cf">for</span> node <span class="kw">in</span> nodes_info):</a>
			<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="co"># Seleciona apenas os vértices brancos</span></a>
			<a class="sourceLine" id="cb3-5" data-line-number="5">    white_nodes <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> nodes_info <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>]</a>
			<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="co"># Seleciona o vértice com menor lambda</span></a>
			<a class="sourceLine" id="cb3-7" data-line-number="7">    min_node <span class="op">=</span> <span class="bu">min</span>(white_nodes, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>])</a></code></pre></div>
			<p>Com o loop principal iniciado, só nós resta adicionar a visita dos vértices vizinhos ao vértice atual. Para isso, utilizamos outros loop, que itera sobre todos os vértices vizinhos, checando se a nova distância é menor que o lambda armazenado. Se for, os valores de lambda e pi são atualizados. Ao final desse loop, só nos resta atualizar a cor do vértice que visitamos nessa iteração e atualizar a lista de nós.</p>
			<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co"># Itera sobre todos os vizinhos do vértice, e atualiza os atributos se necessário</span></a>
			<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="cf">for</span> node <span class="kw">in</span> graph.neighbors(min_node[<span class="dv">0</span>]):</a>
			<a class="sourceLine" id="cb4-3" data-line-number="3">    node_info <span class="op">=</span> (node, <span class="bu">dict</span>(nodes_info)[node])</a>
			<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="cf">if</span> node_info[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>:</a>
			<a class="sourceLine" id="cb4-5" data-line-number="5">        new_dist <span class="op">=</span> graph.get_edge_data(min_node[<span class="dv">0</span>], node_info[<span class="dv">0</span>])[<span class="st">&#39;weight&#39;</span>]</a>
			<a class="sourceLine" id="cb4-6" data-line-number="6">        <span class="co"># Checa se é necessário atualizar os atributos</span></a>
			<a class="sourceLine" id="cb4-7" data-line-number="7">        <span class="cf">if</span> new_dist <span class="op">&lt;</span> node_info[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]:</a>
			<a class="sourceLine" id="cb4-8" data-line-number="8">            nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: new_dist}, <span class="st">&#39;lambda&#39;</span>)</a>
			<a class="sourceLine" id="cb4-9" data-line-number="9">            nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: min_node[<span class="dv">0</span>]}, <span class="st">&#39;pi&#39;</span>)</a>
			<a class="sourceLine" id="cb4-10" data-line-number="10">nx.set_node_attributes(graph, {min_node[<span class="dv">0</span>]: <span class="st">&#39;black&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
			<a class="sourceLine" id="cb4-11" data-line-number="11">nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
			<p>Assim que o algoritmo é finalizado, e todos os vértices recebem um pai, assim como um lambda representando a distância mínima, o único passo restante é montar a árvore com os dados. Devemos então, iterar sobre todos os nós, adicionando arestas utilizando o valor do nó, o valor de pi como pai e o valor de lambda como peso.</p>
			<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># Adiciona os nós à mst</span></a>
			<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="cf">for</span> node <span class="kw">in</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>):</a>
			<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</a>
			<a class="sourceLine" id="cb5-4" data-line-number="4">        edge_weight <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]</a>
			<a class="sourceLine" id="cb5-5" data-line-number="5">        parent <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>]</a>
			<a class="sourceLine" id="cb5-6" data-line-number="6">        mst.add_weighted_edges_from([[parent, node[<span class="dv">0</span>], edge_weight]])</a></code></pre></div>
			<p>O código final para a função <code>prim</code> fica:</p>
			<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co"># Função que implementa o algoritmo de Prim. Recebe um nx.Graph e retorna um nx.DiGraph</span></a>
			<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">def</span> prim(graph):</a>
			<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="co"># Inicializa as cores dos vértices como branco</span></a>
			<a class="sourceLine" id="cb6-4" data-line-number="4">    nx.set_node_attributes(graph, <span class="st">&#39;white&#39;</span>, <span class="st">&#39;color&#39;</span>)</a>
			<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
			<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="co"># Inicializa o pi(pai) dos vértices como None</span></a>
			<a class="sourceLine" id="cb6-7" data-line-number="7">    nx.set_node_attributes(graph, <span class="va">None</span>, <span class="st">&#39;pi&#39;</span>)</a>
			<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
			<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="co"># Inicializa o lambda(distância mínima) dos vértices como infinito</span></a>
			<a class="sourceLine" id="cb6-10" data-line-number="10">    <span class="co"># O vértice inicial recebe 0</span></a>
			<a class="sourceLine" id="cb6-11" data-line-number="11">    nx.set_node_attributes(graph, <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>), <span class="st">&#39;lambda&#39;</span>)</a>
			<a class="sourceLine" id="cb6-12" data-line-number="12">    <span class="cf">for</span> node <span class="kw">in</span> graph.nodes:</a>
			<a class="sourceLine" id="cb6-13" data-line-number="13">        nx.set_node_attributes(graph, {node: <span class="dv">0</span>}, <span class="st">&#39;lambda&#39;</span>)</a>
			<a class="sourceLine" id="cb6-14" data-line-number="14">        <span class="cf">break</span>   <span class="co"># Executa o loop para apenas um nó</span></a>
			<a class="sourceLine" id="cb6-15" data-line-number="15"></a>
			<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="co"># Enquanto existir um vértice não visitado, continua visitando</span></a>
			<a class="sourceLine" id="cb6-17" data-line-number="17">    nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>) <span class="co"># nos dá todos os vértices do grafo, junto com seus atributos</span></a>
			<a class="sourceLine" id="cb6-18" data-line-number="18">    <span class="cf">while</span> <span class="bu">any</span>(node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span> <span class="cf">for</span> node <span class="kw">in</span> nodes_info):</a>
			<a class="sourceLine" id="cb6-19" data-line-number="19">        <span class="co"># Seleciona apenas os vértices brancos</span></a>
			<a class="sourceLine" id="cb6-20" data-line-number="20">        white_nodes <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> nodes_info <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>]</a>
			<a class="sourceLine" id="cb6-21" data-line-number="21">        <span class="co"># Seleciona o vértice com menor lambda</span></a>
			<a class="sourceLine" id="cb6-22" data-line-number="22">        min_node <span class="op">=</span> <span class="bu">min</span>(white_nodes, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>])</a>
			<a class="sourceLine" id="cb6-23" data-line-number="23"></a>
			<a class="sourceLine" id="cb6-24" data-line-number="24">        <span class="co"># Itera sobre todos os vizinhos do vértice, e atualiza os atributos se necessário</span></a>
			<a class="sourceLine" id="cb6-25" data-line-number="25">        <span class="cf">for</span> node <span class="kw">in</span> graph.neighbors(min_node[<span class="dv">0</span>]):</a>
			<a class="sourceLine" id="cb6-26" data-line-number="26">            node_info <span class="op">=</span> (node, <span class="bu">dict</span>(nodes_info)[node])</a>
			<a class="sourceLine" id="cb6-27" data-line-number="27">            <span class="cf">if</span> node_info[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>:</a>
			<a class="sourceLine" id="cb6-28" data-line-number="28">                new_dist <span class="op">=</span> graph.get_edge_data(min_node[<span class="dv">0</span>], node_info[<span class="dv">0</span>])[<span class="st">&#39;weight&#39;</span>]</a>
			<a class="sourceLine" id="cb6-29" data-line-number="29">                <span class="co"># Checa se é necessário atualizar os atributos</span></a>
			<a class="sourceLine" id="cb6-30" data-line-number="30">                <span class="cf">if</span> new_dist <span class="op">&lt;</span> node_info[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]:</a>
			<a class="sourceLine" id="cb6-31" data-line-number="31">                    nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: new_dist}, <span class="st">&#39;lambda&#39;</span>)</a>
			<a class="sourceLine" id="cb6-32" data-line-number="32">                    nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: min_node[<span class="dv">0</span>]}, <span class="st">&#39;pi&#39;</span>)</a>
			<a class="sourceLine" id="cb6-33" data-line-number="33"></a>
			<a class="sourceLine" id="cb6-34" data-line-number="34">        nx.set_node_attributes(graph, {min_node[<span class="dv">0</span>]: <span class="st">&#39;black&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
			<a class="sourceLine" id="cb6-35" data-line-number="35">        nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a>
			<a class="sourceLine" id="cb6-36" data-line-number="36"></a>
			<a class="sourceLine" id="cb6-37" data-line-number="37">    <span class="co"># Digrafo resultante</span></a>
			<a class="sourceLine" id="cb6-38" data-line-number="38">    mst <span class="op">=</span> nx.DiGraph()</a>
			<a class="sourceLine" id="cb6-39" data-line-number="39"></a>
			<a class="sourceLine" id="cb6-40" data-line-number="40">    <span class="co"># Adiciona os nós à mst</span></a>
			<a class="sourceLine" id="cb6-41" data-line-number="41">    <span class="cf">for</span> node <span class="kw">in</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>):</a>
			<a class="sourceLine" id="cb6-42" data-line-number="42">        <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</a>
			<a class="sourceLine" id="cb6-43" data-line-number="43">            edge_weight <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]</a>
			<a class="sourceLine" id="cb6-44" data-line-number="44">            parent <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>]</a>
			<a class="sourceLine" id="cb6-45" data-line-number="45">            mst.add_weighted_edges_from([[parent, node[<span class="dv">0</span>], edge_weight]])</a>
			<a class="sourceLine" id="cb6-46" data-line-number="46"></a>
			<a class="sourceLine" id="cb6-47" data-line-number="47">    <span class="cf">return</span> mst</a></code></pre></div>

                        <hr>

                        <!-- BFS and DFS -->
                        <h1 class="section-heading">BFS e DFS</h1>
                        
                        <hr>

                        <!-- Dijkstra -->
                        <h1 class="section-heading">Dijkstra</h1>
                        
                        <hr>
                    </div>
                </div>
            </div>
        </article>
    <script>hljs.initHighlightingOnLoad();</script>
    </body>
</html>
