<html>
    <head>
        <meta charset="utf-8">
        <title>Trabalho Final Grafos - UFSCar 2017/1</title>

        <!-- Bootstrap Core CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">

        <!-- Template Custom Fonts -->
        <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Clean Blog CSS -->
        <link href="pages/css/clean-blog.css" rel="stylesheet" type="text/css">

        <!-- Highlight JS -->
        <link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    </head>

    <body>
        <!-- Page Header -->
        <header class="masthead" style="background-image: url('pages/img/header.jpg')">
            <div class="overlay"></div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-md-10 mx-auto">
                        <div class="site-heading">
                            <h1>Grafos</h1>
                            <span class="subheading">Universidade Federal de São Carlos</span>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Page Content -->        
        <article>
            <div class="container">
                <div class="row">
                    <div class="col-lg-11 col-md-11 mx-auto">
                        <!-- Introduction -->
                        <p>Esse site é um agregado de pequenos tutoriais para a disciplina de Teoria dos Grafos, do segundo semestre do ano de 2017, ministrada pelo Prof. Dr. Alexandre Levada. Os alunos integrantes desse grupo são:</p>
                        <ul>
                            <li>Gabriel de Souza Alves      726515</li>
                            <li>Jéssica</li>
                            <li>Matheus Bortoleto da Silva  726570</li>
                        </ul>
                        <p>Os tópicos que esse trabalho busca abordar são:</p>
                        <ul>
                            <li><a href="#markov">Cadeia de Markov</a></li>
                            <li><a href="#prim">Algoritmo de Prim</a></li>
                            <li><a href="#bfsdfs">BFS e DFS</a></li>
                            <li><a href="#dijkstra">Algoritmo de Dijkstra</a></li>
							<li><a href="#tsp">Problema do Caixeiro Viajante</a></li>
                        </ul>

                        <!-- Markov Chain -->
                        <h1 id="markov" class="section-heading">Cadeia de Markov</h1>
						<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">def</span> markov_chain(shift):</a>
						<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="co"># Builds the Markov Chain for the table which indicates the probability of reaching a table square from another</span></a>
						<a class="sourceLine" id="cb1-3" data-line-number="3">    chain <span class="op">=</span> np.zeros(shape<span class="op">=</span>(<span class="dv">36</span>,<span class="dv">36</span>))</a>
						<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(chain)):</a>
						<a class="sourceLine" id="cb1-5" data-line-number="5">        <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(chain[x])):</a>
						<a class="sourceLine" id="cb1-6" data-line-number="6">            <span class="cf">if</span> (x<span class="op">+</span><span class="dv">1</span>) <span class="op">&lt;</span> <span class="dv">36</span> <span class="kw">and</span> y <span class="op">&gt;</span> x:</a>
						<a class="sourceLine" id="cb1-7" data-line-number="7">                <span class="cf">if</span> shift[x<span class="op">+</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">0</span>:</a>
						<a class="sourceLine" id="cb1-8" data-line-number="8">                    chain[x][x<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="fl">0.5</span></a>
						<a class="sourceLine" id="cb1-9" data-line-number="9">                <span class="cf">else</span>:</a>
						<a class="sourceLine" id="cb1-10" data-line-number="10">                    chain[x][shift[x<span class="op">+</span><span class="dv">1</span>]] <span class="op">=</span> <span class="fl">0.5</span></a>
						<a class="sourceLine" id="cb1-11" data-line-number="11">            <span class="cf">if</span> (x<span class="op">+</span><span class="dv">2</span>) <span class="op">&lt;</span> <span class="dv">36</span> <span class="kw">and</span> y <span class="op">&gt;</span> x:</a>
						<a class="sourceLine" id="cb1-12" data-line-number="12">                <span class="cf">if</span> shift[x<span class="op">+</span><span class="dv">2</span>] <span class="op">==</span> <span class="dv">0</span>:</a>
						<a class="sourceLine" id="cb1-13" data-line-number="13">                    chain[x][x<span class="op">+</span><span class="dv">2</span>] <span class="op">=</span> <span class="fl">0.5</span></a>
						<a class="sourceLine" id="cb1-14" data-line-number="14">                <span class="cf">else</span>:</a>
						<a class="sourceLine" id="cb1-15" data-line-number="15">                    chain[x][shift[x<span class="op">+</span><span class="dv">2</span>]] <span class="op">=</span> <span class="fl">0.5</span></a>
						<a class="sourceLine" id="cb1-16" data-line-number="16">    <span class="cf">return</span> chain</a>
						<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
						<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="kw">def</span> power_method(markov, times):</a>
						<a class="sourceLine" id="cb1-19" data-line-number="19">    A <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">36</span>)]</a>
						<a class="sourceLine" id="cb1-20" data-line-number="20">    A[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></a>
						<a class="sourceLine" id="cb1-21" data-line-number="21"></a>
						<a class="sourceLine" id="cb1-22" data-line-number="22">    <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(times):</a>
						<a class="sourceLine" id="cb1-23" data-line-number="23">        pos <span class="op">=</span> []</a>
						<a class="sourceLine" id="cb1-24" data-line-number="24">        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">36</span>):</a>
						<a class="sourceLine" id="cb1-25" data-line-number="25">            pos.append(<span class="dv">0</span>)</a>
						<a class="sourceLine" id="cb1-26" data-line-number="26">            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">36</span>):</a>
						<a class="sourceLine" id="cb1-27" data-line-number="27">                pos[i] <span class="op">+=</span> A[j]<span class="op">*</span>markov[j][i]</a>
						<a class="sourceLine" id="cb1-28" data-line-number="28">        A <span class="op">=</span> pos</a>
						<a class="sourceLine" id="cb1-29" data-line-number="29">    <span class="cf">return</span> A</a></code></pre></div>

                        <hr>

                        <!-- Prim -->
                        <h1 id="prim" class="section-heading">Algoritmo de Prim</h1>
                        <p>O algoritmo de Prim é um dos mais utilizados para encontrar árvores mínimas geradoras, ou MSTs, dado um determinado grafo. Nesse tutorial, iremos criar passo à passo uma função que nos retorna uma MST, utilizando Prim.</p>
						<p>Inicialmente, criamos uma função chamada prim, que recebe um objeto do tipo <code>networkx.Graph</code>. Esse é o grafo que será utilizado para encontrar a árvore mínima geradora. Também iremos adicionar um novo objeto na função, chamado de <code>mst</code>, que será retornado no final da execução. Essa será a árvore resultante.</p>
						<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co"># Função que implementa o algoritmo de Prim. Recebe um nx.Graph e retorna um nx.DiGraph</span></a>
						<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">def</span> prim(graph):</a>
						<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
						<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="co"># Digrafo resultante</span></a>
						<a class="sourceLine" id="cb1-5" data-line-number="5">    mst <span class="op">=</span> nx.DiGraph()</a>
						<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
						<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="cf">return</span> mst</a></code></pre></div>
						<p>O passo seguinte é adicionar as propriedades de <em>cor (branco se não visitado, preto se foi), lambda (distância mínima encontrada) e pi (pai do vértice)</em>. Para isso, podemos utilizar os atributos das vértices do próprio grafo recebido pela função. Inicializamos então todos os vértices com a cor branca, todos eles sem pai e todos menos o vértice inicial com a lambda infinito. O lambda do vértice inicial deve receber 0, para que o algoritmo tenha um vértice para começar.</p>
						<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># Inicializa as cores dos vértices como branco</span></a>
						<a class="sourceLine" id="cb2-2" data-line-number="2">nx.set_node_attributes(graph, <span class="st">&#39;white&#39;</span>, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
						<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="co"># Inicializa o pi(pai) dos vértices como None</span></a>
						<a class="sourceLine" id="cb2-5" data-line-number="5">nx.set_node_attributes(graph, <span class="va">None</span>, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
						<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="co"># Inicializa o lambda(distância mínima) dos vértices como infinito</span></a>
						<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="co"># O vértice inicial recebe 0</span></a>
						<a class="sourceLine" id="cb2-9" data-line-number="9">nx.set_node_attributes(graph, <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>), <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="cf">for</span> node <span class="kw">in</span> graph.nodes:</a>
						<a class="sourceLine" id="cb2-11" data-line-number="11">    nx.set_node_attributes(graph, {node: <span class="dv">0</span>}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="cf">break</span>   <span class="co"># Executa o loop para apenas um nó</span></a></code></pre></div>
						<p>Em seguida, iremos criar o loop principal, que será executado enquanto existirem vértices com a cor branca (não visitados). Ele deverá selecionar o vértice com menor lambda. Para isso, fazemos o seguinte:</p>
						<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co"># Enquanto existir um vértice não visitado, continua visitando</span></a>
						<a class="sourceLine" id="cb3-2" data-line-number="2">nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>) <span class="co"># nos dá todos os vértices do grafo, junto com seus atributos</span></a>
						<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="cf">while</span> <span class="bu">any</span>(node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span> <span class="cf">for</span> node <span class="kw">in</span> nodes_info):</a>
						<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="co"># Seleciona apenas os vértices brancos</span></a>
						<a class="sourceLine" id="cb3-5" data-line-number="5">    white_nodes <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> nodes_info <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>]</a>
						<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="co"># Seleciona o vértice com menor lambda</span></a>
						<a class="sourceLine" id="cb3-7" data-line-number="7">    min_node <span class="op">=</span> <span class="bu">min</span>(white_nodes, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>])</a></code></pre></div>
						<p>Com o loop principal iniciado, só nós resta adicionar a visita dos vértices vizinhos ao vértice atual. Para isso, utilizamos outros loop, que itera sobre todos os vértices vizinhos, checando se a nova distância é menor que o lambda armazenado. Se for, os valores de lambda e pi são atualizados. Ao final desse loop, só nos resta atualizar a cor do vértice que visitamos nessa iteração e atualizar a lista de nós.</p>
						<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co"># Itera sobre todos os vizinhos do vértice, e atualiza os atributos se necessário</span></a>
						<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="cf">for</span> node <span class="kw">in</span> graph.neighbors(min_node[<span class="dv">0</span>]):</a>
						<a class="sourceLine" id="cb4-3" data-line-number="3">    node_info <span class="op">=</span> (node, <span class="bu">dict</span>(nodes_info)[node])</a>
						<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="cf">if</span> node_info[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>:</a>
						<a class="sourceLine" id="cb4-5" data-line-number="5">        new_dist <span class="op">=</span> graph.get_edge_data(min_node[<span class="dv">0</span>], node_info[<span class="dv">0</span>])[<span class="st">&#39;weight&#39;</span>]</a>
						<a class="sourceLine" id="cb4-6" data-line-number="6">        <span class="co"># Checa se é necessário atualizar os atributos</span></a>
						<a class="sourceLine" id="cb4-7" data-line-number="7">        <span class="cf">if</span> new_dist <span class="op">&lt;</span> node_info[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]:</a>
						<a class="sourceLine" id="cb4-8" data-line-number="8">            nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: new_dist}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb4-9" data-line-number="9">            nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: min_node[<span class="dv">0</span>]}, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb4-10" data-line-number="10">nx.set_node_attributes(graph, {min_node[<span class="dv">0</span>]: <span class="st">&#39;black&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb4-11" data-line-number="11">nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
						<p>Assim que o algoritmo é finalizado, e todos os vértices recebem um pai, assim como um lambda representando a distância mínima, o único passo restante é montar a árvore com os dados. Devemos então, iterar sobre todos os nós, adicionando arestas utilizando o valor do nó, o valor de pi como pai e o valor de lambda como peso.</p>
						<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># Adiciona os nós à mst</span></a>
						<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="cf">for</span> node <span class="kw">in</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>):</a>
						<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</a>
						<a class="sourceLine" id="cb5-4" data-line-number="4">        edge_weight <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]</a>
						<a class="sourceLine" id="cb5-5" data-line-number="5">        parent <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>]</a>
						<a class="sourceLine" id="cb5-6" data-line-number="6">        mst.add_weighted_edges_from([[parent, node[<span class="dv">0</span>], edge_weight]])</a></code></pre></div>
						<p>O código final para a função <code>prim</code> fica:</p>
						<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co"># Função que implementa o algoritmo de Prim. Recebe um nx.Graph e retorna um nx.DiGraph</span></a>
						<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">def</span> prim(graph):</a>
						<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="co"># Inicializa as cores dos vértices como branco</span></a>
						<a class="sourceLine" id="cb6-4" data-line-number="4">    nx.set_node_attributes(graph, <span class="st">&#39;white&#39;</span>, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
						<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="co"># Inicializa o pi(pai) dos vértices como None</span></a>
						<a class="sourceLine" id="cb6-7" data-line-number="7">    nx.set_node_attributes(graph, <span class="va">None</span>, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
						<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="co"># Inicializa o lambda(distância mínima) dos vértices como infinito</span></a>
						<a class="sourceLine" id="cb6-10" data-line-number="10">    <span class="co"># O vértice inicial recebe 0</span></a>
						<a class="sourceLine" id="cb6-11" data-line-number="11">    nx.set_node_attributes(graph, <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>), <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb6-12" data-line-number="12">    <span class="cf">for</span> node <span class="kw">in</span> graph.nodes:</a>
						<a class="sourceLine" id="cb6-13" data-line-number="13">        nx.set_node_attributes(graph, {node: <span class="dv">0</span>}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb6-14" data-line-number="14">        <span class="cf">break</span>   <span class="co"># Executa o loop para apenas um nó</span></a>
						<a class="sourceLine" id="cb6-15" data-line-number="15"></a>
						<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="co"># Enquanto existir um vértice não visitado, continua visitando</span></a>
						<a class="sourceLine" id="cb6-17" data-line-number="17">    nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>) <span class="co"># nos dá todos os vértices do grafo, junto com seus atributos</span></a>
						<a class="sourceLine" id="cb6-18" data-line-number="18">    <span class="cf">while</span> <span class="bu">any</span>(node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span> <span class="cf">for</span> node <span class="kw">in</span> nodes_info):</a>
						<a class="sourceLine" id="cb6-19" data-line-number="19">        <span class="co"># Seleciona apenas os vértices brancos</span></a>
						<a class="sourceLine" id="cb6-20" data-line-number="20">        white_nodes <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> nodes_info <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>]</a>
						<a class="sourceLine" id="cb6-21" data-line-number="21">        <span class="co"># Seleciona o vértice com menor lambda</span></a>
						<a class="sourceLine" id="cb6-22" data-line-number="22">        min_node <span class="op">=</span> <span class="bu">min</span>(white_nodes, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>])</a>
						<a class="sourceLine" id="cb6-23" data-line-number="23"></a>
						<a class="sourceLine" id="cb6-24" data-line-number="24">        <span class="co"># Itera sobre todos os vizinhos do vértice, e atualiza os atributos se necessário</span></a>
						<a class="sourceLine" id="cb6-25" data-line-number="25">        <span class="cf">for</span> node <span class="kw">in</span> graph.neighbors(min_node[<span class="dv">0</span>]):</a>
						<a class="sourceLine" id="cb6-26" data-line-number="26">            node_info <span class="op">=</span> (node, <span class="bu">dict</span>(nodes_info)[node])</a>
						<a class="sourceLine" id="cb6-27" data-line-number="27">            <span class="cf">if</span> node_info[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>:</a>
						<a class="sourceLine" id="cb6-28" data-line-number="28">                new_dist <span class="op">=</span> graph.get_edge_data(min_node[<span class="dv">0</span>], node_info[<span class="dv">0</span>])[<span class="st">&#39;weight&#39;</span>]</a>
						<a class="sourceLine" id="cb6-29" data-line-number="29">                <span class="co"># Checa se é necessário atualizar os atributos</span></a>
						<a class="sourceLine" id="cb6-30" data-line-number="30">                <span class="cf">if</span> new_dist <span class="op">&lt;</span> node_info[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]:</a>
						<a class="sourceLine" id="cb6-31" data-line-number="31">                    nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: new_dist}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb6-32" data-line-number="32">                    nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: min_node[<span class="dv">0</span>]}, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb6-33" data-line-number="33"></a>
						<a class="sourceLine" id="cb6-34" data-line-number="34">        nx.set_node_attributes(graph, {min_node[<span class="dv">0</span>]: <span class="st">&#39;black&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb6-35" data-line-number="35">        nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a>
						<a class="sourceLine" id="cb6-36" data-line-number="36"></a>
						<a class="sourceLine" id="cb6-37" data-line-number="37">    <span class="co"># Digrafo resultante</span></a>
						<a class="sourceLine" id="cb6-38" data-line-number="38">    mst <span class="op">=</span> nx.DiGraph()</a>
						<a class="sourceLine" id="cb6-39" data-line-number="39"></a>
						<a class="sourceLine" id="cb6-40" data-line-number="40">    <span class="co"># Adiciona os nós à mst</span></a>
						<a class="sourceLine" id="cb6-41" data-line-number="41">    <span class="cf">for</span> node <span class="kw">in</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>):</a>
						<a class="sourceLine" id="cb6-42" data-line-number="42">        <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</a>
						<a class="sourceLine" id="cb6-43" data-line-number="43">            edge_weight <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]</a>
						<a class="sourceLine" id="cb6-44" data-line-number="44">            parent <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>]</a>
						<a class="sourceLine" id="cb6-45" data-line-number="45">            mst.add_weighted_edges_from([[parent, node[<span class="dv">0</span>], edge_weight]])</a>
						<a class="sourceLine" id="cb6-46" data-line-number="46"></a>
						<a class="sourceLine" id="cb6-47" data-line-number="47">    <span class="cf">return</span> mst</a></code></pre></div>
						<p>O resultado da aplicação desse algoritmo, para esse <a href="pages/data/ha30_dist.txt">conjunto de dados</a>, pode ser visto na imagem a seguir:</p>

						<img src="pages/img/prim.jpeg" alt="Resultado da aplicação de Prim" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">

                        <hr>

                        <!-- BFS and DFS -->
                        <h1 id="bfsdfs" class="section-heading">BFS e DFS</h1>
						<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">def</span> bfs(graph, start):</a>
						<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="co"># Make a copy of the original graph to work on</span></a>
						<a class="sourceLine" id="cb1-3" data-line-number="3">    graph_cpy <span class="op">=</span> graph.copy()</a>
						<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
						<a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="co"># Initialize all nodes to white color, infinite distance and no parent</span></a>
						<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="cf">for</span> node <span class="kw">in</span> graph_cpy:</a>
						<a class="sourceLine" id="cb1-7" data-line-number="7">        nx.set_node_attributes(graph_cpy, <span class="st">&#39;white&#39;</span>, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb1-8" data-line-number="8">        nx.set_node_attributes(graph_cpy, <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>), <span class="st">&#39;min_dist&#39;</span>)</a>
						<a class="sourceLine" id="cb1-9" data-line-number="9">        nx.set_node_attributes(graph_cpy, <span class="va">None</span>, <span class="st">&#39;parent&#39;</span>)</a>
						<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
						<a class="sourceLine" id="cb1-11" data-line-number="11">    <span class="co"># Initialize starting node to gray color, 0 distance</span></a>
						<a class="sourceLine" id="cb1-12" data-line-number="12">    nx.set_node_attributes(graph_cpy, {start:<span class="st">&#39;gray&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb1-13" data-line-number="13">    nx.set_node_attributes(graph_cpy, {start:<span class="dv">0</span>}, <span class="st">&#39;min_dist&#39;</span>)</a>
						<a class="sourceLine" id="cb1-14" data-line-number="14"></a>
						<a class="sourceLine" id="cb1-15" data-line-number="15">    <span class="co"># Initialize the queue and push the starting node into it</span></a>
						<a class="sourceLine" id="cb1-16" data-line-number="16">    Q <span class="op">=</span> []</a>
						<a class="sourceLine" id="cb1-17" data-line-number="17">    Q.append(start)</a>
						<a class="sourceLine" id="cb1-18" data-line-number="18">    <span class="cf">while</span> <span class="bu">len</span>(Q) <span class="op">&gt;</span> <span class="dv">0</span>:</a>
						<a class="sourceLine" id="cb1-19" data-line-number="19">        cur <span class="op">=</span> Q.pop()</a>
						<a class="sourceLine" id="cb1-20" data-line-number="20">        <span class="cf">for</span> nbr <span class="kw">in</span> nx.all_neighbors(graph_cpy, cur):</a>
						<a class="sourceLine" id="cb1-21" data-line-number="21">            <span class="cf">if</span> graph_cpy.node[nbr][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>:</a>
						<a class="sourceLine" id="cb1-22" data-line-number="22">                nx.set_node_attributes(graph_cpy, {nbr:graph_cpy.node[cur][<span class="st">&#39;min_dist&#39;</span>] <span class="op">+</span> <span class="dv">1</span>}, <span class="st">&#39;min_dist&#39;</span>)</a>
						<a class="sourceLine" id="cb1-23" data-line-number="23">                nx.set_node_attributes(graph_cpy, {nbr:<span class="st">&#39;gray&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb1-24" data-line-number="24">                nx.set_node_attributes(graph_cpy, {nbr:cur}, <span class="st">&#39;parent&#39;</span>)</a>
						<a class="sourceLine" id="cb1-25" data-line-number="25">                Q.append(nbr)</a>
						<a class="sourceLine" id="cb1-26" data-line-number="26">        nx.set_node_attributes(graph_cpy, {cur:<span class="st">&#39;black&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb1-27" data-line-number="27">    </a>
						<a class="sourceLine" id="cb1-28" data-line-number="28">    <span class="co"># Build the resulting tree</span></a>
						<a class="sourceLine" id="cb1-29" data-line-number="29">    tree <span class="op">=</span> nx.DiGraph()</a>
						<a class="sourceLine" id="cb1-30" data-line-number="30"></a>
						<a class="sourceLine" id="cb1-31" data-line-number="31">    <span class="co"># Insert starting node</span></a>
						<a class="sourceLine" id="cb1-32" data-line-number="32">    tree.add_node(start)</a>
						<a class="sourceLine" id="cb1-33" data-line-number="33"></a>
						<a class="sourceLine" id="cb1-34" data-line-number="34">    <span class="co"># Insert remaining nodes</span></a>
						<a class="sourceLine" id="cb1-35" data-line-number="35">    <span class="cf">for</span> n <span class="kw">in</span> graph_cpy:</a>
						<a class="sourceLine" id="cb1-36" data-line-number="36">        tree.add_edge(graph_cpy.node[n][<span class="st">&#39;parent&#39;</span>], n)</a>
						<a class="sourceLine" id="cb1-37" data-line-number="37"></a>
						<a class="sourceLine" id="cb1-38" data-line-number="38">    <span class="cf">return</span> tree</a></code></pre></div>
						<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">def</span> dfs(graph, start):</a>
						<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="co"># Make a copy of the original graph to work on</span></a>
						<a class="sourceLine" id="cb2-3" data-line-number="3">    graph_cpy <span class="op">=</span> graph.copy()</a>
						<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
						<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="co"># Initialize all nodes to white color and no parent</span></a>
						<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="cf">for</span> node <span class="kw">in</span> graph_cpy:</a>
						<a class="sourceLine" id="cb2-7" data-line-number="7">        nx.set_node_attributes(graph_cpy, <span class="st">&#39;white&#39;</span>, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb2-8" data-line-number="8">        nx.set_node_attributes(graph_cpy, <span class="va">None</span>, <span class="st">&#39;parent&#39;</span>)</a>
						<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
						<a class="sourceLine" id="cb2-10" data-line-number="10">    <span class="co"># Initialize global time</span></a>
						<a class="sourceLine" id="cb2-11" data-line-number="11">    <span class="kw">global</span> time</a>
						<a class="sourceLine" id="cb2-12" data-line-number="12">    time <span class="op">=</span> <span class="dv">0</span></a>
						<a class="sourceLine" id="cb2-13" data-line-number="13">   </a>
						<a class="sourceLine" id="cb2-14" data-line-number="14">    <span class="co"># Start the DFS traversal in the graph</span></a>
						<a class="sourceLine" id="cb2-15" data-line-number="15">    dfs_visit(graph_cpy, start)</a>
						<a class="sourceLine" id="cb2-16" data-line-number="16">    </a>
						<a class="sourceLine" id="cb2-17" data-line-number="17">    <span class="co"># Build the resulting tree</span></a>
						<a class="sourceLine" id="cb2-18" data-line-number="18">    tree <span class="op">=</span> nx.DiGraph()</a>
						<a class="sourceLine" id="cb2-19" data-line-number="19"></a>
						<a class="sourceLine" id="cb2-20" data-line-number="20">    <span class="co"># Insert starting node</span></a>
						<a class="sourceLine" id="cb2-21" data-line-number="21">    tree.add_node(start)</a>
						<a class="sourceLine" id="cb2-22" data-line-number="22"></a>
						<a class="sourceLine" id="cb2-23" data-line-number="23">    <span class="co"># Insert remaining nodes</span></a>
						<a class="sourceLine" id="cb2-24" data-line-number="24">    <span class="cf">for</span> n <span class="kw">in</span> graph_cpy:</a>
						<a class="sourceLine" id="cb2-25" data-line-number="25">        tree.add_edge(graph_cpy.node[n][<span class="st">&#39;parent&#39;</span>], n)</a>
						<a class="sourceLine" id="cb2-26" data-line-number="26"></a>
						<a class="sourceLine" id="cb2-27" data-line-number="27">    <span class="cf">return</span> tree</a>
						<a class="sourceLine" id="cb2-28" data-line-number="28"></a>
						<a class="sourceLine" id="cb2-29" data-line-number="29"><span class="kw">def</span> dfs_visit(graph, cur):</a>
						<a class="sourceLine" id="cb2-30" data-line-number="30">    <span class="co"># Increment time for each call</span></a>
						<a class="sourceLine" id="cb2-31" data-line-number="31">    <span class="kw">global</span> time</a>
						<a class="sourceLine" id="cb2-32" data-line-number="32">    time <span class="op">+=</span> <span class="dv">1</span></a>
						<a class="sourceLine" id="cb2-33" data-line-number="33">    </a>
						<a class="sourceLine" id="cb2-34" data-line-number="34">    <span class="co"># Set time of discovery for each new node and mark as visited</span></a>
						<a class="sourceLine" id="cb2-35" data-line-number="35">    nx.set_node_attributes(graph, {cur:time}, <span class="st">&#39;time_discovery&#39;</span>)</a>
						<a class="sourceLine" id="cb2-36" data-line-number="36">    nx.set_node_attributes(graph, {cur:<span class="st">&#39;gray&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb2-37" data-line-number="37">    </a>
						<a class="sourceLine" id="cb2-38" data-line-number="38">    <span class="co"># Visit all unvisited neighbouring nodes</span></a>
						<a class="sourceLine" id="cb2-39" data-line-number="39">    <span class="cf">for</span> nbr <span class="kw">in</span> nx.all_neighbors(graph, cur):</a>
						<a class="sourceLine" id="cb2-40" data-line-number="40">        <span class="cf">if</span> graph.node[nbr][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>:</a>
						<a class="sourceLine" id="cb2-41" data-line-number="41">            nx.set_node_attributes(graph, {nbr:cur}, <span class="st">&#39;parent&#39;</span>)</a>
						<a class="sourceLine" id="cb2-42" data-line-number="42">            dfs_visit(graph, nbr)</a>
						<a class="sourceLine" id="cb2-43" data-line-number="43"></a>
						<a class="sourceLine" id="cb2-44" data-line-number="44">    <span class="co"># Mark current node as finished and set time of finish</span></a>
						<a class="sourceLine" id="cb2-45" data-line-number="45">    nx.set_node_attributes(graph, {cur:<span class="st">&#39;black&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb2-46" data-line-number="46">    time <span class="op">+=</span> <span class="dv">1</span></a>
						<a class="sourceLine" id="cb2-47" data-line-number="47">    nx.set_node_attributes(graph, {cur:time}, <span class="st">&#39;time_finish&#39;</span>)</a></code></pre></div>
						<p>Resultados:</p>

						<img src="pages/img/bfs.jpeg" alt="Resultado da aplicação de BFS" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">
						<hr>

						<img src="pages/img/dfs.jpeg" alt="Resultado da aplicação de DFS" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">

                        
                        <hr>

                        <!-- Dijkstra -->
                        <h1 id="dijkstra" class="section-heading">Algoritmo de Dijkstra</h1>
						<p>Encontrar caminhos mínimos utilizando grafos é um problema muito comum no nosso dia-a-dia. Os aplicativos que trabalham com mapas e rotas, na maior parte das vezes, tem que encontrar caminhos mínimos entre dois lugares. Para isso, é possível utilizar o algoritmo de Dijkstra, que nos permite buscar uma árvore de caminhos mínimos em um grafo, partindo de um ponto. Existe também a possibilidade de iniciarmos a busca de caminhos mínimos por mais de um ponto, para diversificar a geração de caminhos.</p>
						<p>Iremos então, implementar o algoritmo de Dijkstra multi-origens. Para isso, inicialmente criamos uma função chamada <code>dijkstra</code>, que recebe um <em>grafo</em> do tipo <code>networkx.Graph</code>, assim com um valor <em>sources</em>, que determina a quantidade de origens para o algoritmo.</p>
						<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co"># Função que implementa o algoritmo de Dijkstra.</span></a>
						<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">def</span> dijkstra(graph, sources):</a>
						<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
						<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="co"># Árvore resultante</span></a>
						<a class="sourceLine" id="cb1-5" data-line-number="5">    tree <span class="op">=</span> nx.DiGraph()</a>
						<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
						<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="cf">return</span> tree</a></code></pre></div>
						<p>Em seguida, seguiremos a mesma lógica do algoritmo de Prim, alterando apenas a inicialização dos vértices origem. Portanto, cada vértice tem atributos <em>cor</em>, <em>lambda</em> e <em>pi</em>, elas significando respectivamente, se o vértice foi o visitado, a distância mínima total para aquele vértice encontrado e o pai daquele vértice. Temos então a inicialização dos mesmos:</p>
						<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># Inicializa a cor dos vértices (white: não visitado, black: visitado)</span></a>
						<a class="sourceLine" id="cb2-2" data-line-number="2">nx.set_node_attributes(graph, <span class="st">&#39;white&#39;</span>, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co"># Inicializa a lambda (distância mínima total dos vértices) como infinito</span></a>
						<a class="sourceLine" id="cb2-4" data-line-number="4">nx.set_node_attributes(graph, <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>), <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co"># Seleciona &#39;n&#39; elementos para iniciar o algoritmo (minimum distance = 0)</span></a>
						<a class="sourceLine" id="cb2-6" data-line-number="6">nodes <span class="op">=</span> random.sample(graph.nodes, sources)</a>
						<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="cf">for</span> node <span class="kw">in</span> nodes:</a>
						<a class="sourceLine" id="cb2-8" data-line-number="8">    nx.set_node_attributes(graph, {node: <span class="dv">0</span>}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="co"># Inicializa os o pai dos vértices como None</span></a>
						<a class="sourceLine" id="cb2-10" data-line-number="10">nx.set_node_attributes(graph, <span class="va">None</span>, <span class="st">&#39;pi&#39;</span>)</a></code></pre></div>
						<p>Logo depois, selecionamos todos os vértices e suas informações. Utilizando esses dados, criamos o loop principal, que executa enquanto existirem nós não visitados. Dentro desse loop, é necessário escolher qual será o próximo nó a ser visitado. Isso é determinado pelo menor valor de lambda, de um vértice não visitado.</p>
						<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co"># Enquanto existir um vértice não visitado, continua executando o algortimo</span></a>
						<a class="sourceLine" id="cb3-2" data-line-number="2">nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a>
						<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="cf">while</span> <span class="bu">any</span>(node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span> <span class="cf">for</span> node <span class="kw">in</span> nodes_info):</a>
						<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="co"># Seleciona os nós brancos, e em seguida, seleciona o nó com menor lambda que ainda não foi visitado</span></a>
						<a class="sourceLine" id="cb3-5" data-line-number="5">    white_nodes <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> nodes_info <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>]</a>
						<a class="sourceLine" id="cb3-6" data-line-number="6">    min_node <span class="op">=</span> <span class="bu">min</span>(white_nodes, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]) </a></code></pre></div>
						<p>Assim que selecionamos o vértice a ser analisado, iteramos sobre todos os seus vizinhos, checando se é necessário atualizar os valores de lambda e pi. Esse processo é semelhante ao algoritmo de Prim, a única diferença é que lambda nesse caso não é somente o valor da aresta, e sim a distância total do caminho. Portanto, temos:</p>
						<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co"># Itera sobre todos os vizinhos nó vértice selecionado.</span></a>
						<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="cf">for</span> node <span class="kw">in</span> graph.neighbors(min_node[<span class="dv">0</span>]):</a>
						<a class="sourceLine" id="cb4-3" data-line-number="3">    node_info <span class="op">=</span> (node, nodes_info[node])</a>
						<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="cf">if</span> node_info[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>:</a>
						<a class="sourceLine" id="cb4-5" data-line-number="5">        new_dist <span class="op">=</span> graph.get_edge_data(min_node[<span class="dv">0</span>], node_info[<span class="dv">0</span>])[<span class="st">&#39;weight&#39;</span>] <span class="op">+</span> min_node[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]</a>
						<a class="sourceLine" id="cb4-6" data-line-number="6">        <span class="co"># Checa se é necessário atualizar os valores lambda e pi</span></a>
						<a class="sourceLine" id="cb4-7" data-line-number="7">        <span class="cf">if</span> new_dist <span class="op">&lt;</span> node_info[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]:</a>
						<a class="sourceLine" id="cb4-8" data-line-number="8">            nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: new_dist}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb4-9" data-line-number="9">            nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: min_node[<span class="dv">0</span>]}, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb4-10" data-line-number="10">nx.set_node_attributes(graph, {min_node[<span class="dv">0</span>]: <span class="st">&#39;black&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb4-11" data-line-number="11">nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
						<p>Só nos então, montar a árvore resultante da aplicação do algoritmo. Iteramos sobre cada grafo, adicionado-os com a informação de pi, como vértice pai e o peso da aresta entre o pai e o vértice, como o peso da aresta na árvore.</p>
						<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># Itera sobre todos os vértices, adicionado-os a árvore resultante</span></a>
						<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="cf">for</span> node <span class="kw">in</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>):</a>
						<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>] <span class="op">!=</span> <span class="va">None</span>:</a>
						<a class="sourceLine" id="cb5-4" data-line-number="4">        edge_weight <span class="op">=</span> graph.get_edge_data(node[<span class="dv">0</span>], node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>])</a>
						<a class="sourceLine" id="cb5-5" data-line-number="5">        ancestor <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>]</a>
						<a class="sourceLine" id="cb5-6" data-line-number="6">        tree.add_weighted_edges_from([[ancestor, node[<span class="dv">0</span>], edge_weight]])</a></code></pre></div>
						<p>O algoritmo finalizado é:</p>
						<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co"># Função que implementa o algoritmo de Dijkstra.</span></a>
						<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">def</span> dijkstra(graph, sources):</a>
						<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="co"># Inicializa a cor dos vértices (white: não visitado, black: visitado)</span></a>
						<a class="sourceLine" id="cb6-4" data-line-number="4">    nx.set_node_attributes(graph, <span class="st">&#39;white&#39;</span>, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="co"># Inicializa a lambda (distância mínima total dos vértices) como infinito</span></a>
						<a class="sourceLine" id="cb6-6" data-line-number="6">    nx.set_node_attributes(graph, <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>), <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="co"># Seleciona &#39;n&#39; elementos para iniciar o algoritmo (minimum distance = 0)</span></a>
						<a class="sourceLine" id="cb6-8" data-line-number="8">    nodes <span class="op">=</span> random.sample(graph.nodes, sources)</a>
						<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="cf">for</span> node <span class="kw">in</span> nodes:</a>
						<a class="sourceLine" id="cb6-10" data-line-number="10">        nx.set_node_attributes(graph, {node: <span class="dv">0</span>}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb6-11" data-line-number="11">    <span class="co"># Inicializa os o pai dos vértices como None</span></a>
						<a class="sourceLine" id="cb6-12" data-line-number="12">    nx.set_node_attributes(graph, <span class="va">None</span>, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb6-13" data-line-number="13"></a>
						<a class="sourceLine" id="cb6-14" data-line-number="14">    <span class="co"># Enquanto existir um vértice não visitado, continua executando o algortimo</span></a>
						<a class="sourceLine" id="cb6-15" data-line-number="15">    nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a>
						<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="cf">while</span> <span class="bu">any</span>(node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span> <span class="cf">for</span> node <span class="kw">in</span> nodes_info):</a>
						<a class="sourceLine" id="cb6-17" data-line-number="17">        <span class="co"># Seleciona os nós brancos, e em seguida, seleciona o nó com menor lambda que ainda não foi visitado</span></a>
						<a class="sourceLine" id="cb6-18" data-line-number="18">        white_nodes <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> nodes_info <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>]</a>
						<a class="sourceLine" id="cb6-19" data-line-number="19">        min_node <span class="op">=</span> <span class="bu">min</span>(white_nodes, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]) </a>
						<a class="sourceLine" id="cb6-20" data-line-number="20"></a>
						<a class="sourceLine" id="cb6-21" data-line-number="21">        <span class="co"># Itera sobre todos os vizinhos nó vértice selecionado.</span></a>
						<a class="sourceLine" id="cb6-22" data-line-number="22">        <span class="cf">for</span> node <span class="kw">in</span> graph.neighbors(min_node[<span class="dv">0</span>]):</a>
						<a class="sourceLine" id="cb6-23" data-line-number="23">            node_info <span class="op">=</span> (node, nodes_info[node])</a>
						<a class="sourceLine" id="cb6-24" data-line-number="24">            <span class="cf">if</span> node_info[<span class="dv">1</span>][<span class="st">&#39;color&#39;</span>] <span class="op">==</span> <span class="st">&#39;white&#39;</span>:</a>
						<a class="sourceLine" id="cb6-25" data-line-number="25">                new_dist <span class="op">=</span> graph.get_edge_data(min_node[<span class="dv">0</span>], node_info[<span class="dv">0</span>])[<span class="st">&#39;weight&#39;</span>] <span class="op">+</span> min_node[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]</a>
						<a class="sourceLine" id="cb6-26" data-line-number="26">                <span class="co"># Checa se é necessário atualizar os valores lambda e pi</span></a>
						<a class="sourceLine" id="cb6-27" data-line-number="27">                <span class="cf">if</span> new_dist <span class="op">&lt;</span> node_info[<span class="dv">1</span>][<span class="st">&#39;lambda&#39;</span>]:</a>
						<a class="sourceLine" id="cb6-28" data-line-number="28">                    nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: new_dist}, <span class="st">&#39;lambda&#39;</span>)</a>
						<a class="sourceLine" id="cb6-29" data-line-number="29">                    nx.set_node_attributes(graph, {node_info[<span class="dv">0</span>]: min_node[<span class="dv">0</span>]}, <span class="st">&#39;pi&#39;</span>)</a>
						<a class="sourceLine" id="cb6-30" data-line-number="30">        nx.set_node_attributes(graph, {min_node[<span class="dv">0</span>]: <span class="st">&#39;black&#39;</span>}, <span class="st">&#39;color&#39;</span>)</a>
						<a class="sourceLine" id="cb6-31" data-line-number="31">        nodes_info <span class="op">=</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>)</a>
						<a class="sourceLine" id="cb6-32" data-line-number="32"></a>
						<a class="sourceLine" id="cb6-33" data-line-number="33">    <span class="co"># Árvore resultante</span></a>
						<a class="sourceLine" id="cb6-34" data-line-number="34">    tree <span class="op">=</span> nx.DiGraph()</a>
						<a class="sourceLine" id="cb6-35" data-line-number="35"></a>
						<a class="sourceLine" id="cb6-36" data-line-number="36">    <span class="co"># Itera sobre todos os vértices, adicionado-os a árvore resultante</span></a>
						<a class="sourceLine" id="cb6-37" data-line-number="37">    <span class="cf">for</span> node <span class="kw">in</span> graph.nodes(data<span class="op">=</span><span class="va">True</span>):</a>
						<a class="sourceLine" id="cb6-38" data-line-number="38">        <span class="cf">if</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>] <span class="op">!=</span> <span class="va">None</span>:</a>
						<a class="sourceLine" id="cb6-39" data-line-number="39">            edge_weight <span class="op">=</span> graph.get_edge_data(node[<span class="dv">0</span>], node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>])</a>
						<a class="sourceLine" id="cb6-40" data-line-number="40">            ancestor <span class="op">=</span> node[<span class="dv">1</span>][<span class="st">&#39;pi&#39;</span>]</a>
						<a class="sourceLine" id="cb6-41" data-line-number="41">            tree.add_weighted_edges_from([[ancestor, node[<span class="dv">0</span>], edge_weight]])</a>
						<a class="sourceLine" id="cb6-42" data-line-number="42"></a>
						<a class="sourceLine" id="cb6-43" data-line-number="43">    <span class="cf">return</span> tree</a></code></pre></div>
						<p>O resultado da aplicação desse algoritmo para o <a href="pages/data/wg59_dist.txt">conjunto de dados</a>, pode ser visto na imagem a seguir (primeira imagem tem source=2, e a segunda tem source=3):</p>
						            

						<img src="pages/img/dijkstra2.jpeg" alt="Resultado da aplicação de Dijkstra com duas origens" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">
						<hr>

						<img src="pages/img/dijkstra3.jpeg" alt="Resultado da aplicação de Dijkstra com três origens" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">

                        <hr>

						<!-- TSP -->
                        <h1 id="tsp" class="section-heading">Problema do Caixeiro Viajante</h1>
						<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">def</span> twicearound(graph, source<span class="op">=</span><span class="dv">0</span>):</a>
						<a class="sourceLine" id="cb1-2" data-line-number="2">    mst <span class="op">=</span> nx.minimum_spanning_tree(graph) <span class="co"># gero a mst a partir do grafo original</span></a>
						<a class="sourceLine" id="cb1-3" data-line-number="3">    mst_multi <span class="op">=</span> nx.MultiGraph(mst) <span class="co"># como somente multigrafos aceitam arestas paralelas</span></a>
						<a class="sourceLine" id="cb1-4" data-line-number="4">    </a>
						<a class="sourceLine" id="cb1-5" data-line-number="5">    multi_copy <span class="op">=</span> mst_multi.copy()</a>
						<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="cf">for</span> u,v <span class="kw">in</span> multi_copy.edges():</a>
						<a class="sourceLine" id="cb1-7" data-line-number="7">        mst_multi.add_edge(u,v)     <span class="co">#duplico arestas da mst</span></a>
						<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
						<a class="sourceLine" id="cb1-9" data-line-number="9">    euleraux <span class="op">=</span> <span class="bu">list</span>(nx.eulerian_circuit(mst_multi, source)) <span class="co"># gero um circuito euleriano</span></a>
						<a class="sourceLine" id="cb1-10" data-line-number="10">    cycle <span class="op">=</span> nx.Graph()</a>
						<a class="sourceLine" id="cb1-11" data-line-number="11">    aux <span class="op">=</span> []</a>
						<a class="sourceLine" id="cb1-12" data-line-number="12">    <span class="cf">for</span> u,v <span class="kw">in</span> euleraux: </a>
						<a class="sourceLine" id="cb1-13" data-line-number="13">        aux.append(u)</a>
						<a class="sourceLine" id="cb1-14" data-line-number="14">        aux.append(v)</a>
						<a class="sourceLine" id="cb1-15" data-line-number="15">    h <span class="op">=</span> []</a>
						<a class="sourceLine" id="cb1-16" data-line-number="16">    <span class="cf">for</span> i <span class="kw">in</span> aux: </a>
						<a class="sourceLine" id="cb1-17" data-line-number="17">        <span class="cf">if</span> (i <span class="kw">not</span> <span class="kw">in</span> h):    <span class="co"># elimino repeticoes</span></a>
						<a class="sourceLine" id="cb1-18" data-line-number="18">            h.append(i)</a>
						<a class="sourceLine" id="cb1-19" data-line-number="19">    h.append(source)</a>
						<a class="sourceLine" id="cb1-20" data-line-number="20">    f_weight <span class="op">=</span> <span class="dv">0</span></a>
						<a class="sourceLine" id="cb1-21" data-line-number="21">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span> (<span class="dv">30</span>):</a>
						<a class="sourceLine" id="cb1-22" data-line-number="22">        cycle.add_edge(h[i],h[i<span class="op">+</span><span class="dv">1</span>]) <span class="co"># gero grafo resultante</span></a>
						<a class="sourceLine" id="cb1-23" data-line-number="23">        cycle[h[i]][h[i<span class="op">+</span><span class="dv">1</span>]][<span class="st">&#39;weight&#39;</span>] <span class="op">=</span> graph[h[i]][h[i<span class="op">+</span><span class="dv">1</span>]][<span class="st">&#39;weight&#39;</span>] <span class="co"># copiando tambem o peso</span></a>
						<a class="sourceLine" id="cb1-24" data-line-number="24">        f_weight <span class="op">+=</span> graph[h[i]][h[i<span class="op">+</span><span class="dv">1</span>]][<span class="st">&#39;weight&#39;</span>]</a>
						<a class="sourceLine" id="cb1-25" data-line-number="25">    </a>
						<a class="sourceLine" id="cb1-26" data-line-number="26">    <span class="cf">return</span> (cycle, f_weight)</a></code></pre></div>
						<p>Resultado:</p>

						<img src="pages/img/tsp10results.jpeg" alt="Resultado da aplicação do algoritmo Twice-Around para dez ciclos diferentes" style="max-width: 100%; max-height: 100%; display:block; margin-left: auto; margin-right: auto;">

						<hr>
                    </div>
                </div>
            </div>
        </article>
    <script>hljs.initHighlightingOnLoad();</script>
    </body>
</html>
